###################################################################################
##############################---Question1---######################################
###################################################################################

- Time Complexity: O(n-m) 
    n: length of s
    m: length of t

- Iterate through all substring (call it 'sbs') in 's' where len(sbs) == len(t)
For each 'sbs', check if sbs == anagram(t):
    if Yes: return True
    else: return False
   
- Code Explain:
    a. is_anagram(s,t): Check if s & t are anagrams
    b. question1(s,t): find 'sbs' in 's' and check whether 'sbs' is anagram of 't'
    
- Used for loop and sorting algorithm in Python



###################################################################################
##############################---Question2---######################################
###################################################################################

- Time Complexity: O(n^2)
    n for iterate through 's' in a for loop
    nested n for brutal force search palindrome
    
- For each element in string 's', search palindrome, and only keep the longest

- Code Explain:
    a. helper(s,l,r): Find the longest palindrome for given an element in the string
    b. question2(s): Brutal force search the longest palindrome based on each element, the longest palindrome will be kept and return
        
- Used for loop, nested loop and function in Python



###################################################################################
##############################---Question3---######################################
###################################################################################

- Time Complexity: O(|V|^2)
    V: Vertex, |V| number of vertex
    Using adjacency matrix, go through row & column
    
- Use Prim's Algorithm and adjacency matrix to find MST

- Code Explain:
    a. Convert input dictionary to adjacency matrix
    b. Apply Prim's Algorithm (given visited vertex and their edge, find min weight to unvisited vertex. Prim's Algo is a greedy algo)
    c. Add each selected edge to mst dictionary
        
- Used Prim's algorithm and adjacency matrix (2D list) in Python



###################################################################################
##############################---Question4---######################################
###################################################################################

- Time Complexity: O(logm*logn)
    logm: Search n1's parent
    logn: Search n2's parent 
    
- Find all parent for n1 and check the parents for n2, return the first parent of n2 appeared in n1's parents list

- Code Explain:
    a. parent(T, node): return parent of node
    b. question4(T, r, n1, n2): Calculate all parents for n1 and store them in a list, find the parent of n2 which appear first in n1's parent list, return first appear common parent, if not find return root.
        
- Used recursion and list



###################################################################################
##############################---Question5---######################################
###################################################################################

- Time Complexity: O(n)
    a fast pointer will iterate until the last node 
    
- Two methods provided here:
    list_method: Store linked_list in list and access element use []
    double_pointer_method: A fast pointer will start m steps in advance, when it reach the end, the slow pointer will reach m-th from the end

- Code Explain:
    a. class Node(object): Linked List structure
    b. print_ll(head): A helper function which will print the entire linked list
    c. list_method(head, m): find m-th from the end using a list
    d. question5(head, m): double pointer method. A fast pointer will start m steps in advance, when it reach the end, the slow pointer will reach m-th from the end
        
- Used linked list, double pointer method in Python

